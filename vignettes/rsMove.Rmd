---
title: "rsMove - Remote Sensing for Movement Ecology"
author: "Ruben Remelgado"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rsMove - Remote Sensing for Movement Ecology}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
# load packages
library(rsMove)
library(raster)
library(ggplot2)
library(knitr)
library(kableExtra)
```

</br>

### Introduction
<p align="justify" style="line-height:200%;">
This vignette demonstrates how `rsMove`^[`rsMove` was developed as part of the Opt4Environment project financed by the funded by the German Aerospace Center (DLR) on behalf of the Federal Ministry for Economic Affairs and Energy (BMWi) with the research grant 50 EE 1403. The movement data we used was provided by the Max Planck institute for Ornithology (MPIo).] can help design a remote sensing based study. We based this example on high resolution movement data from one White Stork (*ciconia ciconia*) collected by the Max Planck Institute for Ornithology ([MPIo](https://www.orn.mpg.de/en)) and provided through MoveBank (see [here](https://doi.org/10.5441/001/1.78152p3q)). `rsMove` offers two subset datasets based of the White Stork movement data: one resampled to a relatively lower temporal resolution showing the individuals migration between Germany and Spain (`longMove`) and one with the original temporal resolution showing movements within the nesting site in Germany (`shortMove`). The files are provided as `SpatialPointsDataFrame`objects and can be accessed with the `data()` command as demonstrated below.
</p>

```{r message=FALSE}
data("longMove")
data("shortMove")
```

<p align="justify" style="line-height:200%;">
In addition, `rsMove` provides two remote sensing datasets. The package offers three Normalized Difference Vegetation Index (NDVI) images derived with Landsat surface reflectances acquired though the Earth Resources Observation and Science (EROS) Center Science Processing Architecture ([ESPA](https://espa.cr.usgs.gov/)) and a land cover map (`landCover`) with 30 m resolution derived from the European [Urban Atlas](https://land.copernicus.eu/local/urban-atlas). Both datasets overlap with the `shortMove` dataset and can be accessed as shown below.
</p>

</br>

```{r message=FALSE}
# read remote sensing data
ndvi <- stack(list.files(system.file('extdata', '', package="rsMove"), 'ndvi.tif', full.names=TRUE))
landCover <- raster(system.file('extdata', 'landCover.tif', package="rsMove"))

# extract ndvi raster dates
file.name <- names(ndvi)
ndvi.dates <- as.Date(paste0(substr(file.name, 2, 5), '-', substr(file.name, 7, 8), '-', substr(file.name, 10, 11)))
```

</br>

### Too much data, too little time. Where to start?
<p align="justify" style="line-height:200%;">
When dealing with large scale movement tracks, it is often important to select representative test sites over which we can test different environmental predictors. This is the case with `longMove` as it extends over Wester Europe. To limit the extent of out study site, we will use `hotMove()`. This function will help us select a representative test sites based on the spatial clustering of movement data. We will cluster the samples using a spatial resolution of 0.1° (~10000 km).
</p>


```{r message=FALSE}
sample.regions <- hotMove(longMove, 0.1, return.shp=TRUE)
```

<p align="justify" style="line-height:200%;">
The function identified 21 unique sample regions. The code below plots the region shapefile showing the relation between the original samples (in black) and the resulting regions (in red). The results suggestz that, from the 21 regions, only a few are visible. This represents locations where samples cluster that are potentially interesting to test new methods. But how can we be sure which ones to use?
</p>

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center"}
plot(longMove@coords[,1], longMove@coords[,2], pch=16, cex=0.5, xlab="Lon", ylab="Lat", cex.lab=1, cex.axis=1)
plot(sample.regions$polygons, col=rgb(1,0,0,0.3), add=TRUE)
```

<p align="justify" style="line-height:200%;">
For that, we can use `hotMoveStats()` to deconstruct the temporal composition of each unique regions. We will provide `hotMoveStats()` with the sample indices acquired through `hotMove()` and the observation date of each sample. Below, we can see the function call as well as the final report. The output informs us that Region 3 is much larger than the other ones accounting for a total of 3011 observation recorded over 83 days within a single temporal segment. This corresponds to the nesting site and would be a good palce to start testing our methods given the high concentration of data.
</p>

```{r}
region.stats <- hotMoveStats(sample.regions$region.id, as.Date(longMove@data$timestamp))
```

```{r, echo=FALSE, results='asis'}
kable_styling(kable(head(region.stats$region.stats, 5), format="html", align="c", full_width=TRUE), "stripped", bootstrap_options="responsive")
```

<p align="justify" style="line-height:200%;">
These observations are better depicted in the plot provided by `hotMoveStats()`, show below. The plot describes the distribution of samples per region as well as the total amount of time spent within them.
</p>

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center", echo=FALSE}
region.stats$region.plot
```

<p align="justify" style="line-height:200%;">
Using the code shown below, the results of `hotMoveStats()` can combine these results with the output of `hotMove()` to show the spatial variabily of the statistical results.
</p>

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center", message=FALSE}
df <- region.stats$region.stats
df$id <- as.character(df$region.id)
pol <- fortify(SpatialPolygonsDataFrame(sample.regions$polygons, df))
pol <- merge(pol, df, by="id")
ggplot(pol, aes(x=long, y=lat, group=id, fill=total.time)) + theme_bw() + geom_polygon() + xlab("Long") + ylab("Lat") + scale_fill_continuous(name="Nr. Days")
ggplot(pol, aes(x=long, y=lat, group=id, fill=nr.samples)) + theme_bw() + geom_polygon() + xlab("Long") + ylab("Lat") + scale_fill_continuous(name="Nr. samples")
```

</br>

### Which satellite to use? Choosing a Spatial and Temporal resolution
<p align="justify" style="line-height:200%;">
Now that we know where to focus, we need to decided which satellite data to use. Assuming we want to use Normalized difference Vegetation Index (NDVI) data, let's use `sMoveRes()` and `tMoveRes()` to quantify the data loss with a few common, open-access sensors, namely Sentinel-2 (10 m), Landsat (30 m) and MODIS (250 m).
</p>


```{r}
s.res <- sMoveRes(xy=shortMove, pixel.res=c(10, 30, 250))
```

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center", echo=FALSE, message=FALSE}
kable_styling(kable(head(s.res$stats, 3), format="html", align="c", full_width=TRUE), "stripped", bootstrap_options="responsive")
s.res$plot
```

<p align="justify" style="line-height:200%;">
`tMoveRes()` does a similar analysis. However, this function uses a static spatial resolution and quantifies the number of samples and sample regions achievd with different temporal resolutions. Let's consider `longMove` as it was collected over several days. As done with ``hotMove()`, we will set the spatial resolution to 0.01 (i.e. ~10 km). regarding the temporal resolution, let's consider the example of MODIS for which we can acquire data every 1, 8 and 16 days. As we can see below, the output is very similar to the one produced by `sMoveRes()`.
</p>

```{r}
t.res <- tMoveRes(xy=longMove, obs.date=as.Date(longMove@data$timestamp), time.res=c(1,8,16), pixel.res=0.01)
```

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center", echo=FALSE, message=FALSE}
kable_styling(kable(head(t.res$stats, 3), format="html", align="c", full_width=TRUE), "stripped", bootstrap_options="responsive")
t.res$plot
```

<p align="justify" style="line-height:200%;">
In addition to these two tools, we have `specVar()`. This function extends on `sMoveRes()` informing on how a spatial resolution reflects the complexity of the landscape. Let's consider that `sMoveRes()` suggested a spatial resolution of 250 m is sufficient. Based on these results, the next question we should consider is: does this reflect the spatial complexity we are trying to capture? Within highly fragmented landscapes, where subtle transitions in land cover may be relevant for the species, this question becomes particular important. To test if a resolution of 250 m is adequate we will use the second layer of `ndvi` as it is the closest to the observation date of `shortMove()`. The image is shown below. 
</p>

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center", fig.show='hold', echo=FALSE}
plot(ndvi[[2]])
```

<p align="justify" style="line-height:200%;">
So what is `specVar()`doing? Well, first, the function  will resample `ndvi`, which has a spatial resolution of 30 m, to 250 m. Then, the function will estimate the Mean Absolute Percent Error (MAPE) for each aggregated pixel estimated as 
</p>

<p align="center" style="line-height:200%;">
$100/n \sum_{i=1}^n |\frac{O_{i} - F_{i}}{O_{i}}|$
</p>

<p align="justify" style="line-height:200%;">
where <i>0</i><sub><i>i</i></sub> are the original values, <i>A</i><sub><i>i</i></sub> the aggregated value and <i>n</i><sub><i>i</i></sub> the number of non-NA pixels in the original `raster`. This is a normalized measure allowing the user to establish comparisons with other variables and time-steps. As shown below, the function provides a `raster` of the MAPE and a histogram with the distribution of its values.
</p>

```{r, warning=FALSE, message=FALSE}
s.var <- specVar(img=ndvi[[2]], pixel.res=(res(ndvi)[1]*2))
```

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center", fig.show='hold', echo=FALSE}
plot(s.var$mape)
s.var$plot
```

</br>

### Overcomming the Difference in Scales
<p align="justify" style="line-height:200%;">
 Let's test this function using `shortMove` and `ndvi`. The original movement dataset has a total of 121 samples and, as we can see below, some of these are concentrated. This is related to the relative large amount of time the animal spent at its nest. As a consequence, some of the pixels are sampled frequently.
</p>

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center", echo=FALSE}
plot(ndvi[[1]], ext=shortMove)
points(shortMove, type="l")
```

<p align="justify" style="line-height:200%;">
Now, let's apply `moveReduce()`. The output, shown below, consists of a `raster` of the total amount of time spent at each pixel and a `SpatialPointsDataFrame`, shown in red. The original samples are represented in black. As we can see in the output, some concentrations of samples are preserved as a result of return trips. Moreover, these are reflected on the raster object where the nest is clearly highlighted with a total time of > 300 minutes (i.e 5h).
</p>

```{r}
obs.time <- strptime(paste0(shortMove@data$date, ' ', shortMove@data$time), format="%Y/%m/%d %H:%M:%S")
reduced.samples <- moveReduce(shortMove, landCover, obs.time, derive.raster=TRUE)
```

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center", echo=FALSE}
plot(reduced.samples$total.time, ext=shortMove)
points(reduced.samples$points, type="l")
points(shortMove)
points(reduced.samples$points, pch=20, col="red")
```

```{r, echo=FALSE}
reduced.samples$points$`Elapsed time (minutes)` <- format(reduced.samples$points$`Elapsed time (minutes)`, digits=3)
kable_styling(kable(head(reduced.samples$points, 5), format="html", align="c", full_width=TRUE), "stripped", bootstrap_options="responsive")
```

<p align="justify" style="line-height:200%;">
Now that we have a reduced sample set, we can use it to query and display its relation with local environmental conditions. Let's try `dataQuery()`. It extend on the `extract()` function of the `raster` package allowing the selection of temporal information for a `SpationPoints` object. For each sample, the `dataQuery()` compares its observation time and the acquisition dates of a each layer of a multi-temporal `RasterStack`. Then, the function returns the closest, non-NA value in time along with its corresponding observation date. Moreover, the user can specify a temporal buffer to constrain the search. Provided a two element´vector, the user can adjust the search before and after the sample observation date. For the purpose of this example, let's consider the closest observation for each sample in `shortMove`. To assure all images in the `ndvi` dataset are considered, we will set a temporal buffer of 30 days in both directions.
</p>

```{r}
env.query <- dataQuery(ndvi, reduced.samples$points, ndvi.dates, as.Date(reduced.samples$points$`Timeststamp (start)`), c(30,30))
```

<p align="justify" style="line-height:200%;">
Now, let's use `plotMove()` to display the spatial distribution of the time spent per pixel - reported by `moveReduce()` - and its corresponding NDVI - reported by `dataQuery()`. The output, shown below, reveals that the animal spent more time in locations with a relatively low NDVI, likely related to resting stops over urban areas.
</p>


```{r, echo=FALSE}
reduced.samples$points$`Elapsed time (minutes)` <- as.numeric(reduced.samples$points$`Elapsed time (minutes)`)
``` 

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center"}
plotMove(reduced.samples$points$x, reduced.samples$points$y, size.var=reduced.samples$points$`Elapsed time (minutes)`, fill.var=env.query$value, var.type="cont")
```


</br>

### What Environmental Variables to Select? See What Your Animal is Doing

<p align="justify" style="line-height:200%;">
 Let's apply the function over the `shortMove` movement data and use the `landCover` dataset as environmental information. As we can see below, we need additionally to specify the data type of `landCover`. Here, setting it to `cat` will force `moveSeg()` to identify a new temporal segment every time a change in land cover occurs. 
</p>

```{r}
seg <- moveSeg(landCover, shortMove, obs.time, data.type="cat")
```


<p align="justify" style="line-height:200%;">
As we can see below, the function provides two main outputs: i) a `data.frame` reporting  on the start, end and elapsed time for each segment and on its corresponding land cover class; ii) a `plot` showing the distribution of time spent at each temporal segment and their corresponding land cover class. Note that when dealing with `raster` objects `moveSeg()` identifies changes based on the grid code independently of the data type.
</p>
<p align="justify" style="line-height:200%;">
The output shows that the animal spent most of the recorded time over the class codes 7 and 21. These correspond respectively to *Open spaces with little or no vegetation* and *Industrial, commercial, public, military and private units* (i.e urban). However, we also notice three additional segments where the animal spent between 10 and 64 minutes. This corresponds to *Arable land*. Knowing that the species is known to use agricultural land for foraging, we can assume that these segments related to the time of feeding.
</p>

```{r, echo=FALSE}
seg$stats$`Total time (minutes)` <- format(seg$stats$`Total time (minutes)`, digits=3)
kable_styling(kable(head(seg$stats, 5), format="html", align="c", full_width=TRUE), "stripped", bootstrap_options="responsive")
```

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center", fig.show='hold', echo=FALSE}
plot(seg$plot)
```

<p align="justify" style="line-height:200%;">
Now that we know the animal spent a significant amount of time over *Arable land*, we can think on how to represent this class using remote sensing. As this qualifies as managed land, one can question if differences in management practices affect the animal decision making. In fact, the output of `moveSeg()` shows us that we did not record any time spent over several segments related to *Arable land*. When dealing with species such as the White Stork, this can particularly relevant. During activities such as crop harvesting, herbivores are attracted to the managed fields in search for food and as consequence, so are predatory species such as the White Stork. Thus, understanding and mapping differences in management practices can be helpful to accurately distinguish relevant resources. And it affects how we use remote sensing data. If intra-class differences in management practices exist, we might be forced to use satellite data with a higher temporal resolution to represent them. To help us detect potential differences in management practices over *Arable land* we can use `timeDir()`. Let's consider our `ndvi` dataset. This contains data acquired in *2013-07-16*, *2013-08-01* and *2013-08-17*. On the other hand, `shortMove` was acquired in *2013-08-04*. As a consequence. we can quantify how the landscape was evolving during the observation date. To reach this, we can estimate the slope between the image acquisition dates and the NDVI. This metric is provided by default with `timeDir()`.
</p>
<p align="justify" style="line-height:200%;">
To do this analysis, let's first remove redundant information `moveReduce()`. Then. let's apply `timeDir()` with a `window.size` of `c(4,13)` to define a temporal buffer of 4 days in the past and 13 days in the future. This will force the function to use the second and third layers in `ndvi`. Below, we can see the output of the function. Together with the statistical metric for each sample, the function plots the spatial distribution on samples colored and sized in accordance with their corresponding statistical value.
</p>

```{r}
# derive reduced sample set
reduced.samples <- moveReduce(shortMove, ndvi, obs.time)
obs.dates <- as.Date(reduced.samples$points$`Timeststamp (start)`)

# estimate temporal changes (estimate slope)
time.change <- timeDir(xy=reduced.samples$points, obs.dates=obs.dates, env.data=ndvi, env.dates=ndvi.dates, temporal.buffer=c(4,13))
```

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center", fig.show='hold', echo=FALSE}
time.change$plot
```

<p align="justify" style="line-height:200%;">
To finalize this analysis, let's focus on the samples that correspond to *Arable land*. To achieve this, we will use the `extract()` function of the `raster` package as subset `shortMove` based on this class. Then, we will plot the time spent per pixel - reported by `moveReduce()` - and the temporal change metric - reported by `timeDir()` - using the function `plotMove()`. The output, shown below, tells us something about the preferences of the species. At a first glance, we can see that the animal visited *Arable land* with a positive trend. This suggests that the vegetation was still achieving its maturity at the time of the visit.
</p>

```{r}
# derived sample subset for arable land
ind <- which(extract(landCover, reduced.samples$points)==2)
al.samples <- reduced.samples$points[ind,]
```

```{r, out.width="98%", fig.height=5, fig.width=10, dpi=600, fig.align="center", fig.show='hold', echo=FALSE}
# plot elapsed time VS temporal change
plotMove(al.samples$x, al.samples$y, size.var=al.samples$`Elapsed time (minutes)`, fill.var=time.change$stats$value[ind], var.type="cont")
```

</br>
</br>
